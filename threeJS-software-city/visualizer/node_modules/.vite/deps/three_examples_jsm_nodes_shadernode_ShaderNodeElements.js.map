{
  "version": 3,
  "sources": ["../../three/examples/jsm/nodes/core/constants.js", "../../three/examples/jsm/nodes/core/Node.js", "../../three/examples/jsm/nodes/core/InputNode.js", "../../three/examples/jsm/nodes/core/UniformNode.js", "../../three/examples/jsm/nodes/core/VaryNode.js", "../../three/examples/jsm/nodes/core/AttributeNode.js", "../../three/examples/jsm/nodes/accessors/UVNode.js", "../../three/examples/jsm/nodes/accessors/TextureNode.js", "../../three/examples/jsm/nodes/core/BypassNode.js", "../../three/examples/jsm/nodes/core/CodeNode.js", "../../three/examples/jsm/nodes/core/ContextNode.js", "../../three/examples/jsm/nodes/core/TempNode.js", "../../three/examples/jsm/nodes/core/ExpressionNode.js", "../../three/examples/jsm/nodes/core/FunctionCallNode.js", "../../three/examples/jsm/nodes/core/FunctionNode.js", "../../three/examples/jsm/nodes/core/InstanceIndexNode.js", "../../three/examples/jsm/nodes/core/PropertyNode.js", "../../three/examples/jsm/nodes/math/OperatorNode.js", "../../three/examples/jsm/nodes/core/VarNode.js", "../../three/examples/jsm/nodes/accessors/BufferNode.js", "../../three/examples/jsm/nodes/accessors/Object3DNode.js", "../../three/examples/jsm/nodes/accessors/CameraNode.js", "../../three/examples/jsm/nodes/accessors/ReferenceNode.js", "../../three/examples/jsm/nodes/accessors/MaterialReferenceNode.js", "../../three/examples/jsm/nodes/accessors/MaterialNode.js", "../../three/examples/jsm/nodes/accessors/ModelNode.js", "../../three/examples/jsm/nodes/utils/JoinNode.js", "../../three/examples/jsm/nodes/core/NodeUniform.js", "../../three/examples/jsm/nodes/core/NodeAttribute.js", "../../three/examples/jsm/nodes/core/NodeVary.js", "../../three/examples/jsm/nodes/core/NodeVar.js", "../../three/examples/jsm/nodes/core/NodeBuilder.js", "../../three/examples/jsm/nodes/utils/SplitNode.js", "../../three/examples/jsm/nodes/math/MathNode.js", "../../three/examples/jsm/nodes/accessors/PositionNode.js", "../../three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js", "../../three/examples/jsm/nodes/accessors/NormalNode.js", "../../three/examples/jsm/nodes/accessors/PointUVNode.js", "../../three/examples/jsm/nodes/accessors/StorageBufferNode.js", "../../three/examples/jsm/nodes/display/FrontFacingNode.js", "../../three/examples/jsm/nodes/gpgpu/ComputeNode.js", "../../three/examples/jsm/nodes/math/CondNode.js", "../../three/examples/jsm/nodes/lights/ReflectedLightNode.js", "../../three/examples/jsm/nodes/utils/ArrayElementNode.js", "../../three/examples/jsm/nodes/utils/ConvertNode.js", "../../three/examples/jsm/nodes/core/ConstNode.js", "../../three/examples/jsm/nodes/shadernode/ShaderNode.js", "../../three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js", "../../three/examples/jsm/nodes/accessors/ReflectNode.js", "../../three/examples/jsm/nodes/accessors/CubeTextureNode.js", "../../three/examples/jsm/nodes/accessors/InstanceNode.js", "../../three/examples/jsm/nodes/accessors/SkinningNode.js", "../../three/examples/jsm/nodes/display/ColorSpaceNode.js", "../../three/examples/jsm/nodes/display/NormalMapNode.js", "../../three/examples/jsm/nodes/display/ToneMappingNode.js", "../../three/examples/jsm/nodes/functions/light/getDistanceAttenuation.js", "../../three/examples/jsm/nodes/lights/LightNode.js", "../../three/examples/jsm/nodes/lights/LightsNode.js", "../../three/examples/jsm/nodes/lights/LightContextNode.js", "../../three/examples/jsm/nodes/utils/MatcapUVNode.js", "../../three/examples/jsm/nodes/utils/MaxMipLevelNode.js", "../../three/examples/jsm/nodes/utils/TimerNode.js", "../../three/examples/jsm/nodes/utils/OscNode.js", "../../three/examples/jsm/nodes/utils/SpriteSheetUVNode.js", "../../three/examples/jsm/nodes/procedural/CheckerNode.js", "../../three/examples/jsm/nodes/fog/FogNode.js", "../../three/examples/jsm/nodes/fog/FogRangeNode.js", "../../three/examples/jsm/nodes/functions/BSDF/F_Schlick.js", "../../three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js", "../../three/examples/jsm/nodes/functions/BSDF/D_GGX.js", "../../three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js", "../../three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js", "../../three/examples/jsm/nodes/functions/material/getGeometryRoughness.js", "../../three/examples/jsm/nodes/functions/material/getRoughness.js", "../../three/examples/jsm/nodes/functions/PhysicalLightingModel.js", "../../three/examples/jsm/nodes/shadernode/ShaderNodeElements.js"],
  "sourcesContent": ["export const NodeShaderStage = {\n\tVertex: 'vertex',\n\tFragment: 'fragment'\n};\n\nexport const NodeUpdateType = {\n\tNone: 'none',\n\tFrame: 'frame',\n\tObject: 'object'\n};\n\nexport const NodeType = {\n\tBoolean: 'bool',\n\tInteger: 'int',\n\tFloat: 'float',\n\tVector2: 'vec2',\n\tVector3: 'vec3',\n\tVector4: 'vec4',\n\tMatrix3: 'mat3',\n\tMatrix4: 'mat4'\n};\n", "import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\n\nlet _nodeId = 0;\n\nclass Node {\n\n\tconstructor( nodeType = null ) {\n\n\t\tthis.nodeType = nodeType;\n\n\t\tthis.updateType = NodeUpdateType.None;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\tget type() {\n\n\t\treturn this.constructor.name;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetUpdateType( /*builder*/ ) {\n\n\t\treturn this.updateType;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode !== undefined && this !== sharedNode ) {\n\n\t\t\treturn sharedNode.analyze( builder );\n\n\t\t}\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tnodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n\n\t\tconst nodeKeys = getNodesKeys( this );\n\n\t\tfor ( const property of nodeKeys ) {\n\n\t\t\tthis[ property ].analyze( builder );\n\n\t\t}\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode !== undefined && this !== sharedNode ) {\n\n\t\t\treturn sharedNode.build( builder, output );\n\n\t\t}\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addStack( this );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\tlet snippet = null;\n\n\t\tif ( isGenerateOnce ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = nodeData.snippet;\n\n\t\t\tif ( snippet === undefined ) {\n\n\t\t\t\tsnippet = this.generate( builder ) || '';\n\n\t\t\t\tnodeData.snippet = snippet;\n\n\t\t\t}\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t} else {\n\n\t\t\tsnippet = this.generate( builder, output ) || '';\n\n\t\t}\n\n\t\tbuilder.removeStack( this );\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( json ) {\n\n\t\tconst nodeKeys = getNodesKeys( this );\n\n\t\tif ( nodeKeys.length > 0 ) {\n\n\t\t\tconst inputNodes = {};\n\n\t\t\tfor ( const property of nodeKeys ) {\n\n\t\t\t\tinputNodes[ property ] = this[ property ].toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmeta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nNode.prototype.isNode = true;\n\nexport default Node;\n", "import Node from './Node.js';\nimport { getValueType, getValueFromType } from './NodeUtils.js';\n\nclass InputNode extends Node {\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.value = value;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value?.toArray?.() || this.value;\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = getValueFromType( data.valueType );\n\t\tthis.value = this.value?.fromArray?.( data.value ) || data.value;\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn('Abstract function.');\n\n\t}\n\n}\n\nInputNode.prototype.isInputNode = true;\n\nexport default InputNode;\n", "import InputNode from './InputNode.js';\n\nclass UniformNode extends InputNode {\n\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, builder.shaderStage, sharedNodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\nUniformNode.prototype.isUniformNode = true;\n\nexport default UniformNode;\n", "import Node from './Node.js';\nimport { NodeShaderStage } from './constants.js';\n\nclass VaryNode extends Node {\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst node = this.node;\n\t\tconst name = this.name;\n\n\t\tconst nodeVary = builder.getVaryFromNode( this, type );\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVary.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeVary, NodeShaderStage.Vertex );\n\n\t\t// force node run in vertex stage\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.Vertex, node, type, propertyName );\n\n\t\treturn builder.getPropertyName( nodeVary );\n\n\t}\n\n}\n\nexport default VaryNode;\n", "import Node from './Node.js';\nimport VaryNode from './VaryNode.js';\n\nclass AttributeNode extends Node {\n\n\tconstructor( attributeName, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attribute = builder.getAttribute( this.getAttributeName( builder ), this.getNodeType( builder ) );\n\n\t\tif ( builder.isShaderStage( 'vertex' ) ) {\n\n\t\t\treturn attribute.name;\n\n\t\t} else {\n\n\t\t\tconst nodeVary = new VaryNode( this );\n\n\t\t\treturn nodeVary.build( builder, attribute.type );\n\n\t\t}\n\n\t}\n\n}\n\nexport default AttributeNode;\n", "import AttributeNode from '../core/AttributeNode.js';\n\nclass UVNode extends AttributeNode {\n\n\tconstructor( index = 0 ) {\n\n\t\tsuper( null, 'vec2' );\n\n\t\tthis.index = index;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'uv' + ( index > 0 ? index + 1 : '' );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\nUVNode.prototype.isUVNode = true;\n\nexport default UVNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport UVNode from './UVNode.js';\n\nclass TextureNode extends UniformNode {\n\n\tconstructor( value, uvNode = new UVNode(), biasNode = null ) {\n\n\t\tsuper( value, 'vec4' );\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.biasNode = biasNode;\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'texture' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet snippet = nodeData.snippet;\n\n\t\t\tif ( snippet === undefined ) {\n\n\t\t\t\tconst uvSnippet = this.uvNode.build( builder, 'vec2' );\n\t\t\t\tconst biasNode = this.biasNode;\n\n\t\t\t\tif ( biasNode !== null ) {\n\n\t\t\t\t\tconst biasSnippet = biasNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getTextureBias( textureProperty, uvSnippet, biasSnippet );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = builder.getTexture( textureProperty, uvSnippet );\n\n\t\t\t\t}\n\n\t\t\t\tnodeData.snippet = snippet;\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, 'vec4', output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\n\t}\n\n}\n\nTextureNode.prototype.isTextureNode = true;\n\nexport default TextureNode;\n", "import Node from './Node.js';\n\nclass BypassNode extends Node {\n\n\tconstructor( returnNode, callNode ) {\n\n\t\tsuper();\n\n\t\tthis.outputNode = returnNode;\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addFlowCode( snippet );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder, output );\n\n\t}\n\n}\n\nBypassNode.prototype.isBypassNode = true;\n\nexport default BypassNode;\n", "import Node from './Node.js';\n\nclass CodeNode extends Node {\n\n\tconstructor( code = '', nodeType = 'code' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.code = code;\n\n\t\tthis._includes = [];\n\n\t}\n\n\tsetIncludes( includes ) {\n\n\t\tthis._includes = includes;\n\n\t\treturn this;\n\n\t}\n\n\tgetIncludes( /*builder*/ ) {\n\n\t\treturn this._includes;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst includes = this.getIncludes( builder );\n\n\t\tfor ( const include of includes ) {\n\n\t\t\tinclude.build( builder );\n\n\t\t}\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\n\t\tnodeCode.code = this.code;\n\n\t\treturn nodeCode.code;\n\n\t}\n\n}\n\nCodeNode.prototype.isCodeNode = true;\n\nexport default CodeNode;\n", "import Node from './Node.js';\n\nclass ContextNode extends Node {\n\n\tconstructor( node, context = {} ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.context = context;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.context } );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nContextNode.prototype.isContextNode = true;\n\nexport default ContextNode;\n", "import Node from './Node.js';\n\nclass TempNode extends Node {\n\n\tconstructor( type ) {\n\n\t\tsuper( type );\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.propertyName !== undefined ) {\n\n\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t} else if ( builder.context.temp !== false && type !== 'void ' && output !== 'void' && nodeData.dependenciesCount > 1 ) {\n\n\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\tconst nodeVar = builder.getVarFromNode( this, type );\n\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\tnodeData.snippet = snippet;\n\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\nTempNode.prototype.isTempNode = true;\n\nexport default TempNode;\n", "import TempNode from './TempNode.js';\n\nclass ExpressionNode extends TempNode {\n\n\tconstructor( snipped = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.snipped = snipped;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snipped = this.snipped;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addFlowCode( snipped );\n\n\t\t} else {\n\n\t\t\treturn `( ${ snipped } )`;\n\n\t\t}\n\n\t}\n\n}\n\nexport default ExpressionNode;\n", "import TempNode from './TempNode.js';\n\nclass FunctionCallNode extends TempNode {\n\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tthis.functionNode = functionNode;\n\t\tthis.parameters = parameters;\n\n\t}\n\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tfor ( const inputNode of inputs ) {\n\n\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\tif ( node !== undefined ) {\n\n\t\t\t\tparams.push( node.build( builder, inputNode.type ) );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\n\n\t}\n\n}\n\nexport default FunctionCallNode;\n", "import CodeNode from './CodeNode.js';\nimport FunctionCallNode from './FunctionCallNode.js';\n\nclass FunctionNode extends CodeNode {\n\n\tconstructor( code = '' ) {\n\n\t\tsuper( code );\n\n\t\tthis.keywords = {};\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tcall( parameters = {} ) {\n\n\t\treturn new FunctionCallNode( this, parameters );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tlet code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tconst keywords = this.keywords;\n\t\tconst keywordsProperties = Object.keys( keywords );\n\n\t\tif ( keywordsProperties.length > 0 ) {\n\n\t\t\tfor ( const property of keywordsProperties ) {\n\n\t\t\t\tconst propertyRegExp = new RegExp( `\\\\b${property}\\\\b`, 'g' );\n\t\t\t\tconst nodeProperty = keywords[ property ].build( builder, 'property' );\n\n\t\t\t\tcode = code.replace( propertyRegExp, nodeProperty );\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeCode.code = code;\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nexport default FunctionNode;\n", "import Node from './Node.js';\n\nclass InstanceIndexNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'uint' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getInstanceIndex();\n\n\t}\n\n}\n\nInstanceIndexNode.prototype.isInstanceIndexNode = true;\n\nexport default InstanceIndexNode;\n", "import Node from './Node.js';\n\nclass PropertyNode extends Node {\n\n\tconstructor( name = null, nodeType = 'vec4' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.name = name;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeVary = builder.getVarFromNode( this, this.getNodeType( builder ) );\n\t\tconst name = this.name;\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVary.name = name;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVary );\n\n\t}\n\n}\n\nexport default PropertyNode;\n", "import TempNode from '../core/TempNode.js';\n\nclass OperatorNode extends TempNode {\n\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tthis.op = op;\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalBNode = bNode;\n\n\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\tfinalBNode = new OperatorNode( op, finalBNode, params[ i ] );\n\n\t\t\t}\n\n\t\t\tbNode = finalBNode;\n\n\t\t}\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = bNode.getNodeType( builder );\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '=' || op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn 'int';\n\n\t\t} else if ( op === '==' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = builder.getTypeLength( output );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\tif ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\treturn typeB;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = bNode.getNodeType( builder );\n\n\t\t\tif ( op === '=' ) {\n\n\t\t\t\ttypeB = typeA;\n\n\t\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = bNode.build( builder, typeB );\n\n\t\tconst outputLength = builder.getTypeLength( output );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tif ( op === '=' ) {\n\n\t\t\t\tbuilder.addFlowCode( `${a} ${this.op} ${b}` );\n\n\t\t\t\treturn a;\n\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `( ${a} ${this.op} ${b} )`, type, output );\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\treturn builder.format( `${a} ${this.op} ${b}`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\nexport default OperatorNode;\n", "import Node from './Node.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass VarNode extends Node {\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t}\n\n\top( op, ...params ) {\n\n\t\tthis.node = new OperatorNode( op, this.node, ...params );\n\n\t\treturn this;\n\n\t}\n\n\tassign( ...params ) {\n\n\t\treturn this.op( '=', ...params );\n\n\t}\n\n\tadd( ...params ) {\n\n\t\treturn this.op( '+', ...params );\n\n\t}\n\n\tsub( ...params ) {\n\n\t\treturn this.op( '-', ...params );\n\n\t}\n\n\tmul( ...params ) {\n\n\t\treturn this.op( '*', ...params );\n\n\t}\n\n\tdiv( ...params ) {\n\n\t\treturn this.op( '/', ...params );\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst node = this.node;\n\n\t\tif ( node.isTempNode === true ) {\n\n\t\t\treturn node.build( builder );\n\n\t\t}\n\n\t\tconst name = this.name;\n\t\tconst type = builder.getVectorType( this.getNodeType( builder ) );\n\n\t\tconst snippet = node.build( builder, type );\n\t\tconst nodeVar = builder.getVarFromNode( this, type );\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVar.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nexport default VarNode;\n", "import UniformNode from '../core/UniformNode.js';\n\nclass BufferNode extends UniformNode {\n\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\nBufferNode.prototype.isBufferNode = true;\n\nexport default BufferNode;\n", "import { Vector3 } from 'three';\nimport Node from '../core/Node.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass Object3DNode extends Node {\n\n\tstatic VIEW_MATRIX = 'viewMatrix';\n\tstatic NORMAL_MATRIX = 'normalMatrix';\n\tstatic WORLD_MATRIX = 'worldMatrix';\n\tstatic POSITION = 'position';\n\tstatic VIEW_POSITION = 'viewPosition';\n\n\tconstructor( scope = Object3DNode.VIEW_MATRIX, object3d = null ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\t\tthis.object3d = object3d;\n\n\t\tthis.updateType = NodeUpdateType.Object;\n\n\t\tthis._uniformNode = new UniformNode( null );\n\n\t}\n\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\treturn 'mat3';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\treturn 'vec3';\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d !== null ? this.object3d : frame.object;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst camera = frame.camera;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\tuniformNode.value = object.modelViewMatrix;\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\tuniformNode.value = object.normalMatrix;\n\n\t\t} else if ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat3';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tthis._uniformNode.nodeType = 'vec3';\n\t\t\tthis._uniformNode.value = new Vector3();\n\n\t\t}\n\n\t\treturn this._uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default Object3DNode;\n", "import Object3DNode from './Object3DNode.js';\n\nclass CameraNode extends Object3DNode {\n\n\tstatic PROJECTION_MATRIX = 'projectionMatrix';\n\n\tconstructor( scope = CameraNode.POSITION ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t}\n\n\t\treturn super.getNodeType( builder );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst camera = frame.camera;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\tuniformNode.value = camera.projectionMatrix;\n\n\t\t} else if ( scope === CameraNode.VIEW_MATRIX ) {\n\n\t\t\tuniformNode.value = camera.matrixWorldInverse;\n\n\t\t} else {\n\n\t\t\tthis.object3d = camera;\n\n\t\t\tsuper.update( frame );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nexport default CameraNode;\n", "import Node from '../core/Node.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass ReferenceNode extends Node {\n\n\tconstructor( property, uniformType, object = null ) {\n\n\t\tsuper();\n\n\t\tthis.property = property;\n\n\t\tthis.uniformType = uniformType;\n\n\t\tthis.object = object;\n\n\t\tthis.node = null;\n\n\t\tthis.updateType = NodeUpdateType.Object;\n\n\t\tthis.setNodeType( uniformType );\n\n\t}\n\n\tsetNodeType( uniformType ) {\n\n\t\tthis.node = new UniformNode( null, uniformType );\n\t\tthis.nodeType = uniformType;\n\n\t\tif ( uniformType === 'color' ) {\n\n\t\t\tthis.nodeType = 'vec3';\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tthis.nodeType = 'vec4';\n\n\t\t}\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.uniformType;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.object !== null ? this.object : frame.object;\n\t\tconst value = object[ this.property ];\n\n\t\tthis.node.value = value;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn this.node.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n}\n\nexport default ReferenceNode;\n", "import ReferenceNode from './ReferenceNode.js';\n\nclass MaterialReferenceNode extends ReferenceNode {\n\n\tconstructor( property, inputType, material = null ) {\n\n\t\tsuper( property, inputType, material );\n\n\t\tthis.material = material;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tthis.object = this.material !== null ? this.material : frame.material;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nexport default MaterialReferenceNode;\n", "import Node from '../core/Node.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MaterialReferenceNode from './MaterialReferenceNode.js';\n\nclass MaterialNode extends Node {\n\n\tstatic ALPHA_TEST = 'alphaTest';\n\tstatic COLOR = 'color';\n\tstatic OPACITY = 'opacity';\n\tstatic SPECULAR = 'specular';\n\tstatic ROUGHNESS = 'roughness';\n\tstatic METALNESS = 'metalness';\n\n\tconstructor( scope = MaterialNode.COLOR ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst scope = this.scope;\n\t\tconst material = builder.context.material;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\treturn material.map !== null ? 'vec4' : 'vec3';\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( scope === MaterialNode.SPECULAR ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS ) {\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.ALPHA_TEST ) {\n\n\t\t\tnode = new MaterialReferenceNode( 'alphaTest', 'float' );\n\n\t\t} else if ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = new MaterialReferenceNode( 'color', 'color' );\n\n\t\t\tif ( material.map !== null && material.map !== undefined && material.map.isTexture === true ) {\n\n\t\t\t\tnode = new OperatorNode( '*', colorNode, new MaterialReferenceNode( 'map', 'texture' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = new MaterialReferenceNode( 'opacity', 'float' );\n\n\t\t\tif ( material.alphaMap !== null && material.alphaMap !== undefined && material.alphaMap.isTexture === true ) {\n\n\t\t\t\tnode = new OperatorNode( '*', opacityNode, new MaterialReferenceNode( 'alphaMap', 'texture' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR ) {\n\n\t\t\tconst specularColorNode = new MaterialReferenceNode( 'specularColor', 'color' );\n\n\t\t\tif ( material.specularColorMap !== null && material.specularColorMap !== undefined && material.specularColorMap.isTexture === true ) {\n\n\t\t\t\tnode = new OperatorNode( '*', specularColorNode, new MaterialReferenceNode( 'specularColorMap', 'texture' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularColorNode;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = new MaterialReferenceNode( scope, outputType );\n\n\t\t}\n\n\t\treturn node.build( builder, output );\n\n\t}\n\n}\n\nexport default MaterialNode;\n", "import Object3DNode from './Object3DNode.js';\n\nclass ModelNode extends Object3DNode {\n\n\tconstructor( scope = ModelNode.VIEW_MATRIX ) {\n\n\t\tsuper( scope );\n\n\t}\n\n}\n\nexport default ModelNode;\n", "import Node from '../core/Node.js';\n\nclass JoinNode extends Node {\n\n\tconstructor( nodes = [] ) {\n\n\t\tsuper();\n\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst nodes = this.nodes;\n\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < nodes.length; i ++ ) {\n\n\t\t\tconst input = nodes[ i ];\n\n\t\t\tconst inputSnippet = input.build( builder );\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\treturn `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nexport default JoinNode;\n", "class NodeUniform {\n\n\tconstructor( name, type, node, needsUpdate = undefined ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.node = node;\n\t\tthis.needsUpdate = needsUpdate;\n\n\t}\n\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n}\n\nNodeUniform.prototype.isNodeUniform = true;\n\nexport default NodeUniform;\n", "class NodeAttribute {\n\n\tconstructor( name, type ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nNodeAttribute.prototype.isNodeAttribute = true;\n\nexport default NodeAttribute;\n", "class NodeVary {\n\n\tconstructor( name, type ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nNodeVary.prototype.isNodeVary = true;\n\nexport default NodeVary;\n", "class NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nNodeVar.prototype.isNodeVar = true;\n\nexport default NodeVar;\n", "import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\n\nimport { REVISION, LinearEncoding } from 'three';\n\nexport const defaultShaderStages = [ 'fragment', 'vertex' ];\nexport const shaderStages = [ ...defaultShaderStages, 'compute' ];\nexport const vector = [ 'x', 'y', 'z', 'w' ];\n\nconst typeFromLength = new Map();\ntypeFromLength.set( 1, 'float' );\ntypeFromLength.set( 2, 'vec2' );\ntypeFromLength.set( 3, 'vec3' );\ntypeFromLength.set( 4, 'vec4' );\ntypeFromLength.set( 9, 'mat3' );\ntypeFromLength.set( 16, 'mat4' );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser ) {\n\n\t\tthis.object = object;\n\t\tthis.material = object.material || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.scene = null;\n\t\tthis.lightsNode = null;\n\t\tthis.fogNode = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.codes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.attributes = [];\n\t\tthis.varys = [];\n\t\tthis.vars = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flow = { code: '' };\n\t\tthis.stack = [];\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: object.material\n\t\t};\n\n\t\tthis.nodesData = new WeakMap();\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.node = null;\n\n\t}\n\n\taddStack( node ) {\n\n\t\t/*\n\t\tif ( this.stack.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.stack.push( node );\n\n\t}\n\n\tremoveStack( node ) {\n\n\t\tconst lastStack = this.stack.pop();\n\n\t\tif ( lastStack !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node stack!' );\n\n\t\t}\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.indexOf( node ) === - 1 ) {\n\n\t\t\tconst updateType = node.getUpdateType( this );\n\n\t\t\tif ( updateType !== NodeUpdateType.None ) {\n\n\t\t\t\tthis.updateNodes.push( node );\n\n\t\t\t}\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetTextureBias( /* textureProperty, uvSnippet, biasSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTextureBias( /* textureProperty, uvSnippet, biasSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t// @TODO: rename to .generateConst()\n\tgetConst( type, value ) {\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst getConst = value => this.getConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n\n\t}\n\n\tisShaderStage( shaderStage ) {\n\n\t\treturn this.shaderStage === shaderStage;\n\n\t}\n\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tlet encoding;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tencoding = map.texture.encoding;\n\n\t\t} else {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length ) {\n\n\t\treturn typeFromLength.get( length );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tlet nodeData = this.nodesData.get( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = { vertex: {}, fragment: {}, compute: {} };\n\n\t\t\tthis.nodesData.set( node, nodeData );\n\n\t\t}\n\n\t\treturn shaderStage !== null ? nodeData[ shaderStage ] : nodeData;\n\n\t}\n\n\tgetUniformFromNode( node, shaderStage, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( 'nodeUniform' + index, type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ];\n\t\t\tconst index = vars.length;\n\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, null );\n\n\t\tlet nodeVary = nodeData.vary;\n\n\t\tif ( nodeVary === undefined ) {\n\n\t\t\tconst varys = this.varys;\n\t\t\tconst index = varys.length;\n\n\t\t\tnodeVary = new NodeVary( 'nodeVary' + index, type );\n\n\t\t\tvarys.push( nodeVary );\n\n\t\t\tnodeData.vary = nodeVary;\n\n\t\t}\n\n\t\treturn nodeVary;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ];\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t}\n\n\tgetFlowData( shaderStage, node ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tthis.node = node;\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\tthis.node = null;\n\n\t\treturn flowData;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: '',\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVarys( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( let index = 0; index < vars.length; index ++ ) {\n\n\t\t\tconst variable = vars[ index ];\n\n\t\t\tsnippet += `${variable.type} ${variable.name}; `;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tfor ( const nodeCode of codes ) {\n\n\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\t// stage 1: analyze nodes to possible optimization and validation\n\n\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tnode.analyze( this );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// stage 2: pre-build vertex code used in fragment shader\n\n\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t}\n\n\t\t// stage 3: generate shader\n\n\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tthis.flowNode( node, shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\n\t\treturn this;\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 ) { // toType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n", "import Node from '../core/Node.js';\nimport { vector } from '../core/NodeBuilder.js';\n\nclass SplitNode extends Node {\n\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.components = components;\n\n\t}\n\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vector.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// need expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength() );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\treturn `${nodeSnippet}.${this.components}`;\n\n\t\t} else {\n\n\t\t\t// ignore components if node is a float\n\n\t\t\treturn node.build( builder );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\nexport default SplitNode;\n", "import TempNode from '../core/TempNode.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport OperatorNode from './OperatorNode.js';\n\nclass MathNode extends TempNode {\n\n\t// 1 input\n\n\tstatic RADIANS = 'radians';\n\tstatic DEGREES = 'degrees';\n\tstatic EXP = 'exp';\n\tstatic EXP2 = 'exp2';\n\tstatic LOG = 'log';\n\tstatic LOG2 = 'log2';\n\tstatic SQRT = 'sqrt';\n\tstatic INVERSE_SQRT = 'inversesqrt';\n\tstatic FLOOR = 'floor';\n\tstatic CEIL = 'ceil';\n\tstatic NORMALIZE = 'normalize';\n\tstatic FRACT = 'fract';\n\tstatic SIN = 'sin';\n\tstatic COS = 'cos';\n\tstatic TAN = 'tan';\n\tstatic ASIN = 'asin';\n\tstatic ACOS = 'acos';\n\tstatic ATAN = 'atan';\n\tstatic ABS = 'abs';\n\tstatic SIGN = 'sign';\n\tstatic LENGTH = 'length';\n\tstatic NEGATE = 'negate';\n\tstatic INVERT = 'invert';\n\tstatic DFDX = 'dFdx';\n\tstatic DFDY = 'dFdy';\n\tstatic SATURATE = 'saturate';\n\tstatic ROUND = 'round';\n\n\t// 2 inputs\n\n\tstatic MIN = 'min';\n\tstatic MAX = 'max';\n\tstatic MOD = 'mod';\n\tstatic STEP = 'step';\n\tstatic REFLECT = 'reflect';\n\tstatic DISTANCE = 'distance';\n\tstatic DOT = 'dot';\n\tstatic CROSS = 'cross';\n\tstatic POW = 'pow';\n\tstatic TRANSFORM_DIRECTION = 'transformDirection';\n\n\t// 3 inputs\n\n\tstatic MIX = 'mix';\n\tstatic CLAMP = 'clamp';\n\tstatic REFRACT = 'refract';\n\tstatic SMOOTHSTEP = 'smoothstep';\n\tstatic FACEFORWARD = 'faceforward';\n\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.method = method;\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\t\tthis.cNode = cNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst isWebGL = builder.renderer.isWebGLRenderer === true;\n\n\t\tif ( isWebGL && ( method === MathNode.DFDX || method === MathNode.DFDY ) && output === 'vec3' ) {\n\n\t\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\t\treturn new JoinNode( [\n\t\t\t\tnew MathNode( method, new SplitNode( a, 'x' ) ),\n\t\t\t\tnew MathNode( method, new SplitNode( a, 'y' ) ),\n\t\t\t\tnew MathNode( method, new SplitNode( a, 'z' ) )\n\t\t\t] ).build( builder );\n\n\t\t} else if ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = a;\n\t\t\tlet tB = b;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tB.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\n\n\t\t\t} else {\n\n\t\t\t\ttA = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tA.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\n\n\t\t\t}\n\n\t\t\tconst mulNode = new SplitNode( new OperatorNode( '*', tA, tB ), 'xyz' );\n\n\t\t\treturn new MathNode( MathNode.NORMALIZE, mulNode ).build( builder );\n\n\t\t} else if ( method === MathNode.SATURATE ) {\n\n\t\t\treturn builder.format( `clamp( ${ a.build( builder, inputType ) }, 0.0, 1.0 )`, type, output );\n\n\t\t} else if ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( -' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.INVERT ) {\n\n\t\t\treturn builder.format( '( 1.0 - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\n\t\t\t\tif ( c !== null ) {\n\n\t\t\t\t\tparams.push( b.build( builder, inputType ), c.build( builder, inputType ) );\n\n\t\t\t\t} else if ( b !== null ) {\n\n\t\t\t\t\tparams.push( b.build( builder, inputType ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\nexport default MathNode;\n", "import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryNode from '../core/VaryNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass PositionNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic WORLD = 'world';\n\tstatic VIEW = 'view';\n\tstatic VIEW_DIRECTION = 'viewDirection';\n\n\tconstructor( scope = PositionNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `position-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === PositionNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'position', 'vec3' );\n\n\t\t} else if ( scope === PositionNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryNode( new PositionNode( PositionNode.GEOMETRY ) );\n\n\t\t} else if ( scope === PositionNode.WORLD ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new ModelNode( ModelNode.WORLD_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW ) {\n\n\t\t\tconst vertexPositionNode = new OperatorNode( '*', new ModelNode( ModelNode.VIEW_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW_DIRECTION ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.NEGATE, new PositionNode( PositionNode.VIEW ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryNode( vertexPositionNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default PositionNode;\n", "import Node from '../core/Node.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport PositionNode from '../accessors/PositionNode.js';\n\nclass ModelViewProjectionNode extends Node {\n\n\tconstructor( position = new PositionNode() ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.position = position;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst position = this.position;\n\n\t\tconst mvpMatrix = new OperatorNode( '*', new CameraNode( CameraNode.PROJECTION_MATRIX ), new ModelNode( ModelNode.VIEW_MATRIX ) );\n\t\tconst mvpNode = new OperatorNode( '*', mvpMatrix, position );\n\n\t\treturn mvpNode.build( builder );\n\n\t}\n\n}\n\nexport default ModelViewProjectionNode;\n", "import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryNode from '../core/VaryNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MathNode from '../math/MathNode.js';\n\nclass NormalNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic WORLD = 'world';\n\tstatic VIEW = 'view';\n\n\tconstructor( scope = NormalNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `normal-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === NormalNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'normal', 'vec3' );\n\n\t\t} else if ( scope === NormalNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryNode( new NormalNode( NormalNode.GEOMETRY ) );\n\n\t\t} else if ( scope === NormalNode.VIEW ) {\n\n\t\t\tconst vertexNormalNode = new OperatorNode( '*', new ModelNode( ModelNode.NORMAL_MATRIX ), new NormalNode( NormalNode.LOCAL ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryNode( vertexNormalNode ) );\n\n\t\t} else if ( scope === NormalNode.WORLD ) {\n\n\t\t\t// To use INVERSE_TRANSFORM_DIRECTION only inverse the param order like this: MathNode( ..., Vector, Matrix );\n\t\t\tconst vertexNormalNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new NormalNode( NormalNode.VIEW ), new CameraNode( CameraNode.VIEW_MATRIX ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryNode( vertexNormalNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default NormalNode;\n", "import Node from '../core/Node.js';\n\nclass PointUVNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n\n\t}\n\n}\n\nPointUVNode.prototype.isPointUVNode = true;\n\nexport default PointUVNode;\n", "import BufferNode from './BufferNode.js';\n\nclass StorageBufferNode extends BufferNode {\n\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType, bufferCount );\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageBuffer';\n\n\t}\n\n}\n\nStorageBufferNode.prototype.isStorageBufferNode = true;\n\nexport default StorageBufferNode;\n", "import Node from '../core/Node.js';\n\nclass FrontFacingNode extends Node {\n\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\nFrontFacingNode.prototype.isFrontFacingNode = true;\n\nexport default FrontFacingNode;\n", "import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass ComputeNode extends Node {\n\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.computeNode = computeNode;\n\n\t\tthis.count = count;\n\t\tthis.workgroupSize = workgroupSize;\n\t\tthis.dispatchCount = 0;\n\n\t\tthis.updateType = NodeUpdateType.Object;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\tupdate( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addFlowCode( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nComputeNode.prototype.isComputeNode = true;\n\nexport default ComputeNode;\n", "import Node from '../core/Node.js';\nimport PropertyNode from '../core/PropertyNode.js';\nimport ContextNode from '../core/ContextNode.js';\n\nclass CondNode extends Node {\n\n\tconstructor( condNode, ifNode, elseNode ) {\n\n\t\tsuper();\n\n\t\tthis.condNode = condNode;\n\n\t\tthis.ifNode = ifNode;\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst ifType = this.ifNode.getNodeType( builder );\n\t\tconst elseType = this.elseNode.getNodeType( builder );\n\n\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\treturn elseType;\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst context = { temp: false };\n\t\tconst nodeProperty = new PropertyNode( null, type ).build( builder );\n\n\t\tconst nodeSnippet = new ContextNode( this.condNode/*, context*/ ).build( builder, 'bool' ),\n\t\t\tifSnippet = new ContextNode( this.ifNode, context ).build( builder, type ),\n\t\t\telseSnippet = new ContextNode( this.elseNode, context ).build( builder, type );\n\n\t\tbuilder.addFlowCode( `if ( ${nodeSnippet} ) {\n\n\\t\\t${nodeProperty} = ${ifSnippet};\n\n\\t} else {\n\n\\t\\t${nodeProperty} = ${elseSnippet};\n\n\\t}` );\n\n\t\treturn nodeProperty;\n\n\t}\n\n}\n\nexport default CondNode;\n", "import TempNode from '../core/Node.js';\nimport VarNode from '../core/VarNode.js';\nimport ConstNode from '../core/UniformNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport { Vector3 } from 'three';\n\nclass ReflectedLightNode extends TempNode {\n\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.directDiffuse = new VarNode( new ConstNode( new Vector3() ), 'DirectDiffuse' );\n\t\tthis.directSpecular = new VarNode( new ConstNode( new Vector3() ), 'DirectSpecular' );\n\t\tthis.indirectDiffuse = new VarNode( new ConstNode( new Vector3() ), 'IndirectDiffuse' );\n\t\tthis.indirectSpecular = new VarNode( new ConstNode( new Vector3() ), 'IndirectSpecular' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = this;\n\n\t\tconst totalLight = new OperatorNode( '+', directDiffuse, directSpecular, indirectDiffuse, indirectSpecular );\n\n\t\treturn totalLight.build( builder );\n\n\t}\n\n}\n\nexport default ReflectedLightNode;\n", "import TempNode from '../core/Node.js';\n\nclass ArrayElementNode extends TempNode {\n\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.indexNode = indexNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, 'uint' );\n\n\t\treturn `${nodeSnippet}[ ${indexSnippet} ]`;\n\n\t}\n\n}\n\nexport default ArrayElementNode;\n", "import Node from '../core/Node.js';\n\nclass ConvertNode extends Node {\n\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.convertTo;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst convertTo = this.convertTo;\n\t\tconst node = this.node;\n\n\t\tif ( builder.isReference( convertTo ) === false ) {\n\n\t\t\tconst nodeSnippet = node.build( builder, convertTo );\n\n\t\t\treturn builder.format( nodeSnippet, this.getNodeType( builder ), convertTo );\n\n\t\t} else {\n\n\t\t\treturn node.build( builder, convertTo );\n\n\t\t}\n\n\t}\n\n}\n\nexport default ConvertNode;\n", "import InputNode from './InputNode.js';\n\nclass ConstNode extends InputNode {\n\n\tgenerateConst( builder ) {\n\n\t\treturn builder.getConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\nConstNode.prototype.isConstNode = true;\n\nexport default ConstNode;\n", "import ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType } from '../core/NodeUtils.js';\n\nconst shaderNodeHandler = {\n\n\tconstruct( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget: function ( node, prop ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = prop\n\t\t\t\t\t.replace( /r|s/g, 'x' )\n\t\t\t\t\t.replace( /g|t/g, 'y' )\n\t\t\t\t\t.replace( /b|p/g, 'z' )\n\t\t\t\t\t.replace( /a|q/g, 'w' );\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( node, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node[ prop ];\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj ) {\n\n\tconst type = typeof obj;\n\n\tif ( ( type === 'number' ) || ( type === 'boolean' ) ) {\n\n\t\treturn nodeObject( getAutoTypedConstNode( obj ) );\n\n\t} else if ( type === 'object' ) {\n\n\t\tif ( obj?.isNode === true ) {\n\n\t\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\t\tif ( nodeObject === undefined ) {\n\n\t\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\t\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t\t}\n\n\t\t\treturn nodeObject;\n\n\t\t}\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ] );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ] );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null ) {\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn nodeObject( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn nodeObject( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nconst ShaderNodeScript = function ( jsFunc ) {\n\n\t// @TODO: Move this to Node extended class\n\n\tconst self = {\n\n\t\tbuild: ( builder ) => {\n\n\t\t\tself.call( {}, builder );\n\n\t\t\treturn '';\n\n\t\t},\n\n\t\tcall: ( inputs, builder ) => {\n\n\t\t\tinputs = nodeObjects( inputs );\n\n\t\t\treturn nodeObject( jsFunc( inputs, builder ) );\n\n\t\t}\n\n\t};\n\n\treturn self;\n\n};\n\nexport const ShaderNode = new Proxy( ShaderNodeScript, shaderNodeHandler );\n\nexport const nodeObject = ( val ) => /* new */ ShaderNodeObject( val );\nexport const nodeObjects = ( val ) => new ShaderNodeObjects( val );\nexport const nodeArray = ( val ) => new ShaderNodeArray( val );\nexport const nodeProxy = ( ...val ) => new ShaderNodeProxy( ...val );\nexport const nodeImmutable = ( ...val ) => new ShaderNodeImmutable( ...val );\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( let bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( let uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( let int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( let float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( let float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nexport const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getAutoTypedConstNode = ( value ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value );\n\n\t}\n\n};\n\nexport const ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 ) {\n\n\t\t\treturn nodeObject( new ConstNode( getValueFromType( type ), type ) );\n\n\t\t} else {\n\n\t\t\tif ( type === 'color' && params[ 0 ].isNode !== true ) {\n\n\t\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t\t}\n\n\t\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\t\treturn cacheMap.get( params[ 0 ] );\n\n\t\t\t}\n\n\t\t\tconst nodes = params.map( getAutoTypedConstNode );\n\n\t\t\tif ( nodes.length === 1 ) {\n\n\t\t\t\treturn nodeObject( nodes[ 0 ].nodeType === type ? nodes[ 0 ] : new ConvertNode( nodes[ 0 ], type ) );\n\n\t\t\t}\n\n\t\t\treturn nodeObject( new ConvertNode( new JoinNode( nodes ), type ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport const getConstNodeType = ( value ) => value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null );\n", "// core\n//import ArrayUniformNode from '../core/ArrayUniformNode.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport BypassNode from '../core/BypassNode.js';\nimport CodeNode from '../core/CodeNode.js';\nimport ContextNode from '../core/ContextNode.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport FunctionCallNode from '../core/FunctionCallNode.js';\nimport FunctionNode from '../core/FunctionNode.js';\nimport InstanceIndexNode from '../core/InstanceIndexNode.js';\nimport PropertyNode from '../core/PropertyNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport VarNode from '../core/VarNode.js';\nimport VaryNode from '../core/VaryNode.js';\n\n// accessors\nimport BufferNode from '../accessors/BufferNode.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport MaterialNode from '../accessors/MaterialNode.js';\nimport MaterialReferenceNode from '../accessors/MaterialReferenceNode.js';\nimport ModelViewProjectionNode from '../accessors/ModelViewProjectionNode.js';\nimport NormalNode from '../accessors/NormalNode.js';\nimport Object3DNode from '../accessors/Object3DNode.js';\nimport PointUVNode from '../accessors/PointUVNode.js';\nimport PositionNode from '../accessors/PositionNode.js';\nimport ReferenceNode from '../accessors/ReferenceNode.js';\nimport StorageBufferNode from '../accessors/StorageBufferNode.js';\nimport TextureNode from '../accessors/TextureNode.js';\nimport UVNode from '../accessors/UVNode.js';\n\n// display\nimport FrontFacingNode from '../display/FrontFacingNode.js';\n\n// gpgpu\nimport ComputeNode from '../gpgpu/ComputeNode.js';\n\n// math\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport CondNode from '../math/CondNode.js';\n\n// lights\nimport ReflectedLightNode from '../lights/ReflectedLightNode.js';\n\n// utils\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\n\n// shader node utils\nimport { ShaderNode, nodeObject, nodeObjects, nodeArray, nodeProxy, nodeImmutable, ConvertType, getConstNodeType, cacheMaps } from './ShaderNode.js';\n\n// shader node utils\n\nexport { ShaderNode, nodeObject, nodeObjects, nodeArray, nodeProxy, nodeImmutable };\n\nexport const color = new ConvertType( 'color' );\n\nexport const float = new ConvertType( 'float', cacheMaps.float );\nexport const int = new ConvertType( 'int', cacheMaps.int );\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\n\nexport const vec2 = new ConvertType( 'vec2' );\nexport const ivec2 = new ConvertType( 'ivec2' );\nexport const uvec2 = new ConvertType( 'uvec2' );\nexport const bvec2 = new ConvertType( 'bvec2' );\n\nexport const vec3 = new ConvertType( 'vec3' );\nexport const ivec3 = new ConvertType( 'ivec3' );\nexport const uvec3 = new ConvertType( 'uvec3' );\nexport const bvec3 = new ConvertType( 'bvec3' );\n\nexport const vec4 = new ConvertType( 'vec4' );\nexport const ivec4 = new ConvertType( 'ivec4' );\nexport const uvec4 = new ConvertType( 'uvec4' );\nexport const bvec4 = new ConvertType( 'bvec4' );\n\nexport const mat3 = new ConvertType( 'mat3' );\nexport const imat3 = new ConvertType( 'imat3' );\nexport const umat3 = new ConvertType( 'umat3' );\nexport const bmat3 = new ConvertType( 'bmat3' );\n\nexport const mat4 = new ConvertType( 'mat4' );\nexport const imat4 = new ConvertType( 'imat4' );\nexport const umat4 = new ConvertType( 'umat4' );\nexport const bmat4 = new ConvertType( 'bmat4' );\n\n// core\n\n// @TODO: ArrayUniformNode\n\nexport const func = ( code ) => {\n\n\tconst node = nodeObject( new FunctionNode( code ) );\n\n\tconst call = node.call.bind( node );\n\tnode.call = ( params ) => nodeObject( call( params ) );\n\n\treturn node;\n\n};\n\nexport const uniform = ( nodeOrType ) => {\n\n\tconst nodeType = getConstNodeType( nodeOrType );\n\n\t// TODO: get ConstNode from .traverse() in the future\n\tconst value = nodeOrType.isNode === true ? nodeOrType.node?.value || nodeOrType.value : nodeOrType;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\nexport const attribute = ( name, nodeOrType ) => nodeObject( new AttributeNode( name, getConstNodeType( nodeOrType ) ) );\nexport const property = ( name, nodeOrType ) => nodeObject( new PropertyNode( name, getConstNodeType( nodeOrType ) ) );\n\nexport const bypass = nodeProxy( BypassNode );\nexport const code = nodeProxy( CodeNode );\nexport const context = nodeProxy( ContextNode );\nexport const expression = nodeProxy( ExpressionNode );\nexport const call = nodeProxy( FunctionCallNode );\nexport const instanceIndex = nodeImmutable( InstanceIndexNode );\nexport const label = nodeProxy( VarNode );\nexport const temp = label;\nexport const vary = nodeProxy( VaryNode );\n\n// accesors\n\nexport const buffer = ( value, nodeOrType, count ) => nodeObject( new BufferNode( value, getConstNodeType( nodeOrType ), count ) );\nexport const storage = ( value, nodeOrType, count ) => nodeObject( new StorageBufferNode( value, getConstNodeType( nodeOrType ), count ) );\n\nexport const cameraProjectionMatrix = nodeImmutable( CameraNode, CameraNode.PROJECTION_MATRIX );\nexport const cameraViewMatrix = nodeImmutable( CameraNode, CameraNode.VIEW_MATRIX );\nexport const cameraNormalMatrix = nodeImmutable( CameraNode, CameraNode.NORMAL_MATRIX );\nexport const cameraWorldMatrix = nodeImmutable( CameraNode, CameraNode.WORLD_MATRIX );\nexport const cameraPosition = nodeImmutable( CameraNode, CameraNode.POSITION );\n\nexport const materialAlphaTest = nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\nexport const materialColor = nodeImmutable( MaterialNode, MaterialNode.COLOR );\nexport const materialOpacity = nodeImmutable( MaterialNode, MaterialNode.OPACITY );\nexport const materialSpecular = nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\nexport const materialRoughness = nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\nexport const materialMetalness = nodeImmutable( MaterialNode, MaterialNode.METALNESS );\n\nexport const diffuseColor = nodeImmutable( PropertyNode, 'DiffuseColor', 'vec4' );\nexport const roughness = nodeImmutable( PropertyNode, 'Roughness', 'float' );\nexport const metalness = nodeImmutable( PropertyNode, 'Metalness', 'float' );\nexport const alphaTest = nodeImmutable( PropertyNode, 'AlphaTest', 'float' );\nexport const specularColor = nodeImmutable( PropertyNode, 'SpecularColor', 'color' );\n\nexport const reference = ( name, nodeOrType, object ) => nodeObject( new ReferenceNode( name, getConstNodeType( nodeOrType ), object ) );\nexport const materialReference = ( name, nodeOrType, material ) => nodeObject( new MaterialReferenceNode( name, getConstNodeType( nodeOrType ), material ) );\n\nexport const modelViewProjection = nodeProxy( ModelViewProjectionNode );\n\nexport const normalGeometry = nodeImmutable( NormalNode, NormalNode.GEOMETRY );\nexport const normalLocal = nodeImmutable( NormalNode, NormalNode.LOCAL );\nexport const normalWorld = nodeImmutable( NormalNode, NormalNode.WORLD );\nexport const normalView = nodeImmutable( NormalNode, NormalNode.VIEW );\nexport const transformedNormalView = nodeImmutable( VarNode, normalView, 'TransformedNormalView' );\n\nexport const viewMatrix = nodeProxy( Object3DNode, Object3DNode.VIEW_MATRIX );\nexport const normalMatrix = nodeProxy( Object3DNode, Object3DNode.NORMAL_MATRIX );\nexport const worldMatrix = nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );\nexport const position = nodeProxy( Object3DNode, Object3DNode.POSITION );\nexport const viewPosition = nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );\n\nexport const positionGeometry = nodeImmutable( PositionNode, PositionNode.GEOMETRY );\nexport const positionLocal = nodeImmutable( PositionNode, PositionNode.LOCAL );\nexport const positionWorld = nodeImmutable( PositionNode, PositionNode.WORLD );\nexport const positionView = nodeImmutable( PositionNode, PositionNode.VIEW );\nexport const positionViewDirection = nodeImmutable( PositionNode, PositionNode.VIEW_DIRECTION );\n\nexport const texture = nodeProxy( TextureNode );\nexport const sampler = ( texture ) => nodeObject( new ConvertNode( texture.isNode === true ? texture : new TextureNode( texture ), 'sampler' ) );\nexport const uv = ( ...params ) => nodeObject( new UVNode( ...params ) );\nexport const pointUV = nodeImmutable( PointUVNode );\n\n// gpgpu\n\nexport const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\n\n// math\n\nexport const EPSILON = float( 1e-6 );\nexport const INFINITY = float( 1e6 );\n\nexport const cond = nodeProxy( CondNode );\n\nexport const add = nodeProxy( OperatorNode, '+' );\nexport const sub = nodeProxy( OperatorNode, '-' );\nexport const mul = nodeProxy( OperatorNode, '*' );\nexport const div = nodeProxy( OperatorNode, '/' );\nexport const remainder = nodeProxy( OperatorNode, '%' );\nexport const equal = nodeProxy( OperatorNode, '==' );\nexport const assign = nodeProxy( OperatorNode, '=' );\nexport const lessThan = nodeProxy( OperatorNode, '<' );\nexport const greaterThan = nodeProxy( OperatorNode, '>' );\nexport const lessThanEqual = nodeProxy( OperatorNode, '<=' );\nexport const greaterThanEqual = nodeProxy( OperatorNode, '>=' );\nexport const and = nodeProxy( OperatorNode, '&&' );\nexport const or = nodeProxy( OperatorNode, '||' );\nexport const xor = nodeProxy( OperatorNode, '^^' );\nexport const bitAnd = nodeProxy( OperatorNode, '&' );\nexport const bitOr = nodeProxy( OperatorNode, '|' );\nexport const bitXor = nodeProxy( OperatorNode, '^' );\nexport const shiftLeft = nodeProxy( OperatorNode, '<<' );\nexport const shiftRight = nodeProxy( OperatorNode, '>>' );\n\nexport const radians = nodeProxy( MathNode, MathNode.RADIANS );\nexport const degrees = nodeProxy( MathNode, MathNode.DEGREES );\nexport const exp = nodeProxy( MathNode, MathNode.EXP );\nexport const exp2 = nodeProxy( MathNode, MathNode.EXP2 );\nexport const log = nodeProxy( MathNode, MathNode.LOG );\nexport const log2 = nodeProxy( MathNode, MathNode.LOG2 );\nexport const sqrt = nodeProxy( MathNode, MathNode.SQRT );\nexport const inversesqrt = nodeProxy( MathNode, MathNode.INVERSE_SQRT );\nexport const floor = nodeProxy( MathNode, MathNode.FLOOR );\nexport const ceil = nodeProxy( MathNode, MathNode.CEIL );\nexport const normalize = nodeProxy( MathNode, MathNode.NORMALIZE );\nexport const fract = nodeProxy( MathNode, MathNode.FRACT );\nexport const sin = nodeProxy( MathNode, MathNode.SIN );\nexport const cos = nodeProxy( MathNode, MathNode.COS );\nexport const tan = nodeProxy( MathNode, MathNode.TAN );\nexport const asin = nodeProxy( MathNode, MathNode.ASIN );\nexport const acos = nodeProxy( MathNode, MathNode.ACOS );\nexport const atan = nodeProxy( MathNode, MathNode.ATAN );\nexport const abs = nodeProxy( MathNode, MathNode.ABS );\nexport const sign = nodeProxy( MathNode, MathNode.SIGN );\nexport const length = nodeProxy( MathNode, MathNode.LENGTH );\nexport const negate = nodeProxy( MathNode, MathNode.NEGATE );\nexport const invert = nodeProxy( MathNode, MathNode.INVERT );\nexport const dFdx = nodeProxy( MathNode, MathNode.DFDX );\nexport const dFdy = nodeProxy( MathNode, MathNode.DFDY );\nexport const saturate = nodeProxy( MathNode, MathNode.SATURATE );\nexport const round = nodeProxy( MathNode, MathNode.ROUND );\n\nexport const min = nodeProxy( MathNode, MathNode.MIN );\nexport const max = nodeProxy( MathNode, MathNode.MAX );\nexport const mod = nodeProxy( MathNode, MathNode.MOD );\nexport const step = nodeProxy( MathNode, MathNode.STEP );\nexport const reflect = nodeProxy( MathNode, MathNode.REFLECT );\nexport const distance = nodeProxy( MathNode, MathNode.DISTANCE );\nexport const dot = nodeProxy( MathNode, MathNode.DOT );\nexport const cross = nodeProxy( MathNode, MathNode.CROSS );\nexport const pow = nodeProxy( MathNode, MathNode.POW );\nexport const pow2 = nodeProxy( MathNode, MathNode.POW, 2 );\nexport const pow3 = nodeProxy( MathNode, MathNode.POW, 3 );\nexport const pow4 = nodeProxy( MathNode, MathNode.POW, 4 );\nexport const transformDirection = nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );\n\nexport const mix = nodeProxy( MathNode, MathNode.MIX );\nexport const clamp = nodeProxy( MathNode, MathNode.CLAMP );\nexport const refract = nodeProxy( MathNode, MathNode.REFRACT );\nexport const smoothstep = nodeProxy( MathNode, MathNode.SMOOTHSTEP );\nexport const faceforward = nodeProxy( MathNode, MathNode.FACEFORWARD );\n\n// display\n\nexport const frontFacing = nodeImmutable( FrontFacingNode );\nexport const faceDirection = sub( mul( float( frontFacing ), 2 ), 1 );\n\n// lights\n\nexport const reflectedLight = nodeProxy( ReflectedLightNode );\n\n// utils\n\nexport const element = nodeProxy( ArrayElementNode );\n\n// miscellaneous\n\nexport const dotNV = saturate( dot( transformedNormalView, positionViewDirection ) );\n", "import Node from '../core/Node.js';\nimport { nodeObject, normalWorld, positionWorld, cameraPosition, sub, normalize, vec3, negate, reflect } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass ReflectNode extends Node {\n\n\tstatic VECTOR = 'vector';\n\tstatic CUBE = 'cube';\n\n\tconstructor( scope = ReflectNode.CUBE ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `reflect-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === ReflectNode.VECTOR ) {\n\n\t\t\tconst cameraToFrag = normalize( sub( positionWorld, cameraPosition ) );\n\t\t\tconst reflectVec = reflect( cameraToFrag, normalWorld );\n\n\t\t\treturn reflectVec.build( builder );\n\n\t\t} else if ( scope === ReflectNode.CUBE ) {\n\n\t\t\tconst reflectVec = nodeObject( new ReflectNode( ReflectNode.VECTOR ) );\n\t\t\tconst cubeUV = vec3( negate( reflectVec.x ), reflectVec.yz );\n\n\t\t\treturn cubeUV.build( builder );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default ReflectNode;\n", "import TextureNode from './TextureNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport ReflectNode from './ReflectNode.js';\n\nclass CubeTextureNode extends TextureNode {\n\n\tconstructor( value, uvNode = new ReflectNode(), biasNode = null ) {\n\n\t\tsuper( value, uvNode, biasNode );\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isCubeTexture !== true ) {\n\n\t\t\tthrow new Error( 'CubeTextureNode: Need a three.js cube texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = UniformNode.prototype.generate.call( this, builder, 'cubeTexture' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet snippet = nodeData.snippet;\n\n\t\t\tif ( snippet === undefined ) {\n\n\t\t\t\tconst uvSnippet = this.uvNode.build( builder, 'vec3' );\n\t\t\t\tconst biasNode = this.biasNode;\n\n\t\t\t\tif ( biasNode !== null ) {\n\n\t\t\t\t\tconst biasSnippet = biasNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getCubeTextureBias( textureProperty, uvSnippet, biasSnippet );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = builder.getCubeTexture( textureProperty, uvSnippet );\n\n\t\t\t\t}\n\n\t\t\t\tnodeData.snippet = snippet;\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, 'vec4', output );\n\n\t\t}\n\n\t}\n\n}\n\nCubeTextureNode.prototype.isCubeTextureNode = true;\n\nexport default CubeTextureNode;\n", "import Node from '../core/Node.js';\nimport {\n\tvec3,\n\tmat3,\n\tmul,\n\tassign,\n\tbuffer,\n\telement,\n\tdot,\n\tdiv,\n\ttemp,\n\tinstanceIndex,\n\tpositionLocal,\n\tnormalLocal\n} from '../shadernode/ShaderNodeBaseElements.js';\n\nclass InstanceNode extends Node {\n\n\tconstructor( instanceMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.instanceMesh = instanceMesh;\n\n\t\t//\n\n\t\tconst instanceBufferNode = buffer( instanceMesh.instanceMatrix.array, 'mat4', instanceMesh.count );\n\n\t\tthis.instanceMatrixNode = temp( element( instanceBufferNode, instanceIndex ) ); // @TODO: a possible caching issue here?\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { instanceMatrixNode } = this;\n\n\t\t// POSITION\n\n\t\tconst instancePosition = mul( instanceMatrixNode, positionLocal ).xyz;\n\n\t\t// NORMAL\n\n\t\tconst m = mat3( instanceMatrixNode[ 0 ].xyz, instanceMatrixNode[ 1 ].xyz, instanceMatrixNode[ 2 ].xyz );\n\n\t\tconst transformedNormal = div( normalLocal, vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) ) );\n\n\t\tconst instanceNormal = mul( m, transformedNormal ).xyz;\n\n\t\t// ASSIGNS\n\n\t\tassign( positionLocal, instancePosition ).build( builder );\n\t\tassign( normalLocal, instanceNormal ).build( builder );\n\n\t}\n\n}\n\nexport default InstanceNode;\n", "import Node from '../core/Node.js';\nimport {\n\tShaderNode,\n\tattribute,\n\tbuffer,\n\tmat4,\n\tuniform,\n\tpositionLocal,\n\tnormalLocal,\n\tassign,\n\telement,\n\tadd,\n\tmul,\n\ttransformDirection\n} from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { NodeUpdateType } from '../core/constants.js';\n\nconst Skinning = new ShaderNode( ( inputs, builder ) => {\n\n\tconst { index, weight, bindMatrix, bindMatrixInverse, boneMatrices } = inputs;\n\n\tconst boneMatX = element( boneMatrices, index.x );\n\tconst boneMatY = element( boneMatrices, index.y );\n\tconst boneMatZ = element( boneMatrices, index.z );\n\tconst boneMatW = element( boneMatrices, index.w );\n\n\t// POSITION\n\n\tconst skinVertex = mul( bindMatrix, positionLocal );\n\n\tconst skinned = add(\n\t\tmul( mul( boneMatX, skinVertex ), weight.x ),\n\t\tmul( mul( boneMatY, skinVertex ), weight.y ),\n\t\tmul( mul( boneMatZ, skinVertex ), weight.z ),\n\t\tmul( mul( boneMatW, skinVertex ), weight.w )\n\t);\n\n\tconst skinPosition = mul( bindMatrixInverse, skinned ).xyz;\n\n\t// NORMAL\n\n\tlet skinMatrix = add(\n\t\tmul( weight.x, boneMatX ),\n\t\tmul( weight.y, boneMatY ),\n\t\tmul( weight.z, boneMatZ ),\n\t\tmul( weight.w, boneMatW )\n\t);\n\n\tskinMatrix = mul( mul( bindMatrixInverse, skinMatrix ), bindMatrix );\n\n\tconst skinNormal = transformDirection( skinMatrix, normalLocal ).xyz;\n\n\t// ASSIGNS\n\n\tassign( positionLocal, skinPosition ).build( builder );\n\tassign( normalLocal, skinNormal ).build( builder );\n\n} );\n\nclass SkinningNode extends Node {\n\n\tconstructor( skinnedMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.skinnedMesh = skinnedMesh;\n\n\t\tthis.updateType = NodeUpdateType.Object;\n\n\t\t//\n\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\tthis.bindMatrixNode = uniform( mat4( skinnedMesh.bindMatrix ) );\n\t\tthis.bindMatrixInverseNode = uniform( mat4( skinnedMesh.bindMatrixInverse ) );\n\t\tthis.boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tSkinning.call( {\n\t\t\tindex: this.skinIndexNode,\n\t\t\tweight: this.skinWeightNode,\n\t\t\tbindMatrix: this.bindMatrixNode,\n\t\t\tbindMatrixInverse: this.bindMatrixInverseNode,\n\t\t\tboneMatrices: this.boneMatricesNode\n\t\t}, builder );\n\n\t}\n\n\tupdate() {\n\n\t\tthis.skinnedMesh.skeleton.update();\n\n\t}\n\n}\n\nexport default SkinningNode;\n", "import TempNode from '../core/Node.js';\nimport { ShaderNode, vec3, pow, mul, sub, mix, vec4, lessThanEqual } from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { LinearEncoding, sRGBEncoding } from 'three';\n\nexport const LinearToLinear = new ShaderNode( ( inputs ) => {\n\n\treturn inputs.value;\n\n} );\n\nexport const LinearTosRGB = new ShaderNode( ( inputs ) => {\n\n\tconst { value } = inputs;\n\n\tconst rgb = value.rgb;\n\n\tconst a = sub( mul( pow( value.rgb, vec3( 0.41666 ) ), 1.055 ), vec3( 0.055 ) );\n\tconst b = mul( rgb, 12.92 );\n\tconst factor = vec3( lessThanEqual( rgb, vec3( 0.0031308 ) ) );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn vec4( rgbResult, value.a );\n\n} );\n\nconst EncodingLib = {\n\tLinearToLinear,\n\tLinearTosRGB\n};\n\nclass ColorSpaceNode extends TempNode {\n\n\tstatic LINEAR_TO_LINEAR = 'LinearToLinear';\n\tstatic LINEAR_TO_SRGB = 'LinearTosRGB';\n\n\tconstructor( method, node ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.method = method;\n\n\t\tthis.node = node;\n\n\t}\n\n\tfromEncoding( encoding ) {\n\n\t\tlet method = null;\n\n\t\tif ( encoding === LinearEncoding ) {\n\n\t\t\tmethod = 'Linear';\n\n\t\t} else if ( encoding === sRGBEncoding ) {\n\n\t\t\tmethod = 'sRGB';\n\n\t\t}\n\n\t\tthis.method = 'LinearTo' + method;\n\n\t\treturn this;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst method = this.method;\n\t\tconst node = this.node;\n\n\t\tif ( method !== ColorSpaceNode.LINEAR_TO_LINEAR ) {\n\n\t\t\tconst encodingFunctionNode = EncodingLib[ method ];\n\n\t\t\treturn encodingFunctionNode.call( {\n\t\t\t\tvalue: node\n\t\t\t} ).build( builder, type );\n\n\t\t} else {\n\n\t\t\treturn node.build( builder, type );\n\n\t\t}\n\n\t}\n\n}\n\nexport default ColorSpaceNode;\n", "import TempNode from '../core/TempNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport { ShaderNode, positionView, normalView, uv, vec3, cond, add, sub, mul, dFdx, dFdy, cross, max, dot, normalize, inversesqrt, equal, faceDirection } from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { TangentSpaceNormalMap, ObjectSpaceNormalMap } from 'three';\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2ArbNode = new ShaderNode( ( inputs ) => {\n\n\tconst { eye_pos, surf_norm, mapN, uv } = inputs;\n\n\tconst q0 = dFdx( eye_pos.xyz );\n\tconst q1 = dFdy( eye_pos.xyz );\n\tconst st0 = dFdx( uv.st );\n\tconst st1 = dFdy( uv.st );\n\n\tconst N = surf_norm; // normalized\n\n\tconst q1perp = cross( q1, N );\n\tconst q0perp = cross( N, q0 );\n\n\tconst T = add( mul( q1perp, st0.x ), mul( q0perp, st1.x ) );\n\tconst B = add( mul( q1perp, st0.y ), mul( q0perp, st1.y ) );\n\n\tconst det = max( dot( T, T ), dot( B, B ) );\n\tconst scale = cond( equal( det, 0 ), 0, mul( faceDirection, inversesqrt( det ) ) );\n\n\treturn normalize( add( mul( T, mul( mapN.x, scale ) ), mul( B, mul( mapN.y, scale ) ), mul( N, mapN.z ) ) );\n\n} );\n\nclass NormalMapNode extends TempNode {\n\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.node = node;\n\t\tthis.scaleNode = scaleNode;\n\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tconst normalOP = mul( this.node, 2.0 );\n\t\tlet normalMap = sub( normalOP, 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tconst normalMapScale = mul( normalMap.xy, scaleNode );\n\t\t\tnormalMap = vec3( normalMapScale, normalMap.z );\n\n\t\t}\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\tconst vertexNormalNode = mul( new ModelNode( ModelNode.NORMAL_MATRIX ), normalMap );\n\n\t\t\tconst normal = normalize( vertexNormalNode );\n\n\t\t\treturn normal.build( builder, type );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\tconst perturbNormal2ArbCall = perturbNormal2ArbNode.call( {\n\t\t\t\teye_pos: positionView,\n\t\t\t\tsurf_norm: normalView,\n\t\t\t\tmapN: normalMap,\n\t\t\t\tuv: uv()\n\t\t\t} );\n\n\t\t\treturn perturbNormal2ArbCall.build( builder, type );\n\n\t\t}\n\n\t}\n\n}\n\nexport default NormalMapNode;\n", "import TempNode from '../core/Node.js';\nimport { ShaderNode, mul, float } from '../shadernode/ShaderNodeBaseElements.js';\n\nimport { LinearToneMapping } from 'three';\n\n// exposure only\nexport const LinearToneMappingNode = new ShaderNode( ( { color, exposure } ) => {\n\n\treturn mul( color, exposure );\n\n} );\n\nclass ToneMappingNode extends TempNode {\n\n\tconstructor( toneMapping, exposureNode = float( 1 ), colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.toneMapping = toneMapping;\n\n\t\tthis.exposureNode = exposureNode;\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst colorNode = this.color || builder.context.color;\n\n\t\tconst toneMapping = this.toneMapping;\n\t\tconst toneMappingParams = { exposure: this.exposureNode, color: colorNode };\n\n\t\tif ( toneMapping === LinearToneMapping ) {\n\n\t\t\treturn LinearToneMappingNode.call( toneMappingParams ).build( builder, type );\n\n\t\t} else {\n\n\t\t\treturn this.colorNode.build( builder, type );\n\n\t\t}\n\n\t}\n\n}\n\nexport default ToneMappingNode;\n", "import {\n\tShaderNode, div, max, sub, mul, saturate, pow, pow2, pow4, cond, greaterThan\n} from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst getDistanceAttenuation = new ShaderNode( ( inputs ) => {\n\n\tconst { lightDistance, cutoffDistance, decayExponent } = inputs;\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tconst distanceFalloff = div( 1.0, max( pow( lightDistance, decayExponent ), 0.01 ) );\n\n\treturn cond(\n\t\tgreaterThan( cutoffDistance, 0 ),\n\t\tmul( distanceFalloff, pow2( saturate( sub( 1.0, pow4( div( lightDistance, cutoffDistance ) ) ) ) ) ),\n\t\tdistanceFalloff\n\t);\n\n} ); // validated\n\nexport default getDistanceAttenuation;\n", "import Node from '../core/Node.js';\nimport Object3DNode from '../accessors/Object3DNode.js';\nimport PositionNode from '../accessors/PositionNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MathNode from '../math/MathNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport getDistanceAttenuation from '../functions/light/getDistanceAttenuation.js';\n\nimport { Color } from 'three';\n\nclass LightNode extends Node {\n\n\tconstructor( light = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.updateType = NodeUpdateType.Object;\n\n\t\tthis.light = light;\n\n\t\tthis._colorNode = new UniformNode( new Color() );\n\n\t\tthis._lightCutoffDistanceNode = new UniformNode( 0 );\n\t\tthis._lightDecayExponentNode = new UniformNode( 0 );\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tupdate( /* frame */ ) {\n\n\t\tthis._colorNode.value.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis._lightCutoffDistanceNode.value = this.light.distance;\n\t\tthis._lightDecayExponentNode.value = this.light.decay;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst lightPositionView = new Object3DNode( Object3DNode.VIEW_POSITION );\n\t\tconst positionView = new PositionNode( PositionNode.VIEW );\n\n\t\tconst lVector = new OperatorNode( '-', lightPositionView, positionView );\n\n\t\tconst lightDirection = new MathNode( MathNode.NORMALIZE, lVector );\n\n\t\tconst lightDistance = new MathNode( MathNode.LENGTH, lVector );\n\n\t\tconst lightAttenuation = getDistanceAttenuation.call( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: this._lightCutoffDistanceNode,\n\t\t\tdecayExponent: this._lightDecayExponentNode\n\t\t} );\n\n\t\tconst lightColor = new OperatorNode( '*', this._colorNode, lightAttenuation );\n\n\t\tlightPositionView.object3d = this.light;\n\n\t\tconst lightingModelFunctionNode = builder.context.lightingModelNode;\n\n\t\tif ( lightingModelFunctionNode !== undefined ) {\n\n\t\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\t\tlightingModelFunctionNode.call( {\n\t\t\t\tlightDirection,\n\t\t\t\tlightColor,\n\t\t\t\treflectedLight\n\t\t\t}, builder );\n\n\t\t}\n\n\t}\n\n}\n\nexport default LightNode;\n", "import Node from '../core/Node.js';\nimport LightNode from './LightNode.js';\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nclass LightsNode extends Node {\n\n\tconstructor( lightNodes = [] ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.lightNodes = lightNodes;\n\n\t\tthis._hash = null;\n\n\t}\n\n\tget hasLight() {\n\n\t\treturn this.lightNodes.length > 0;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst lightNodes = this.lightNodes;\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t\treturn 'vec3( 0.0 )';\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\tif ( this._hash === null ) {\n\n\t\t\tlet hash = '';\n\t\t\t\n\t\t\tconst lightNodes = this.lightNodes;\n\n\t\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\t\thash += lightNode.light.uuid + ' ';\n\n\t\t\t}\n\t\t\t\n\t\t\tthis._hash = hash;\n\t\t\t\n\t\t}\n\n\t\treturn this._hash;\n\n\t}\n\n\tgetLightNodeByHash( hash ) {\n\n\t\tconst lightNodes = this.lightNodes;\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tif ( lightNode.light.uuid === hash ) {\n\n\t\t\t\treturn lightNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfromLights( lights ) {\n\n\t\tconst lightNodes = [];\n\n\t\tlights = sortLights( lights );\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tlet lightNode = this.getLightNodeByHash( light.uuid );\n\n\t\t\tif ( lightNode === null ) {\n\n\t\t\t\tlightNode = new LightNode( light );\n\n\t\t\t}\n\n\t\t\tlightNodes.push( lightNode );\n\n\t\t}\n\n\t\tthis.lightNodes = lightNodes;\n\t\tthis._hash = null;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport default LightsNode;\n", "import ContextNode from '../core/ContextNode.js';\nimport { reflectedLight } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass LightContextNode extends ContextNode {\n\n\tconstructor( node, lightingModelNode = null ) {\n\n\t\tsuper( node );\n\n\t\tthis.lightingModelNode = lightingModelNode;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn 'vec3';\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { lightingModelNode } = this;\n\n\t\tthis.context.reflectedLight = reflectedLight();\n\n\t\tif ( lightingModelNode !== null ) {\n\n\t\t\tthis.context.lightingModelNode = lightingModelNode;\n\n\t\t}\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tsuper.generate( builder, type );\n\n\t\treturn this.context.reflectedLight.build( builder, type );\n\n\t}\n\n}\n\nexport default LightContextNode;\n", "import TempNode from '../core/TempNode.js';\nimport { vec2, vec3, negate, normalize, cross, dot, mul, add, transformedNormalView, positionViewDirection } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass MatcapUVNode extends TempNode {\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst x = normalize( vec3( positionViewDirection.z, 0, negate( positionViewDirection.x ) ) );\n\t\tconst y = cross( positionViewDirection, x );\n\n\t\tconst uv = add( mul( vec2( dot( x, transformedNormalView ), dot( y, transformedNormalView ) ), 0.495 ), 0.5 );\n\n\t\treturn uv.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n}\n\nexport default MatcapUVNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass MaxMipLevelNode extends UniformNode {\n\n\tconstructor( texture ) {\n\n\t\tsuper( 0 );\n\n\t\tthis.texture = texture;\n\n\t\tthis.updateType = NodeUpdateType.Frame;\n\n\t}\n\n\tupdate() {\n\n\t\tconst { width, height } = this.texture.images ? this.texture.images[ 0 ] : this.texture.image;\n\n\t\tthis.value = Math.log( Math.max( width, height ) ) * Math.LOG2E;\n\n\t\tif ( this.value > 0 ) {\n\n\t\t\tthis.updateType = NodeUpdateType.None;\n\n\t\t}\n\n\t}\n\n}\n\nexport default MaxMipLevelNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass TimerNode extends UniformNode {\n\n\tstatic LOCAL = 'local';\n\tstatic GLOBAL = 'global';\n\tstatic DELTA = 'delta';\n\n\tconstructor( scope = TimerNode.LOCAL ) {\n\n\t\tsuper( 0 );\n\n\t\tthis.scope = scope;\n\t\tthis.scale = 1;\n\n\t\tthis.updateType = NodeUpdateType.Frame;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst scope = this.scope;\n\t\tconst scale = this.scale;\n\n\t\tif ( scope === TimerNode.LOCAL ) {\n\n\t\t\tthis.value += frame.deltaTime * scale;\n\n\t\t} else if ( scope === TimerNode.DELTA ) {\n\n\t\t\tthis.value = frame.deltaTime * scale;\n\n\t\t} else {\n\n\t\t\t// global\n\n\t\t\tthis.value = frame.time * scale;\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\t\tdata.scale = this.scale;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\t\tthis.scale = data.scale;\n\n\t}\n\n}\n\nexport default TimerNode;\n", "import Node from '../core/Node.js';\nimport TimerNode from './TimerNode.js';\nimport { abs, fract, round, sin, add, sub, mul } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass OscNode extends Node {\n\n\tstatic SINE = 'sine';\n\tstatic SQUARE = 'square';\n\tstatic TRIANGLE = 'triangle';\n\tstatic SAWTOOTH = 'sawtooth';\n\n\tconstructor( method = OscNode.SINE, timeNode = new TimerNode() ) {\n\n\t\tsuper();\n\n\t\tthis.method = method;\n\t\tthis.timeNode = timeNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.timeNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst method = this.method;\n\t\tconst timeNode = this.timeNode;\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === OscNode.SINE ) {\n\n\t\t\toutputNode = add( mul( sin( mul( add( timeNode, .75 ), Math.PI * 2 ) ), .5 ), .5 );\n\n\t\t} else if ( method === OscNode.SQUARE ) {\n\n\t\t\toutputNode = round( fract( timeNode ) );\n\n\t\t} else if ( method === OscNode.TRIANGLE ) {\n\n\t\t\toutputNode = abs( sub( 1, mul( fract( add( timeNode, .5 ) ), 2 ) ) );\n\n\t\t} else if ( method === OscNode.SAWTOOTH ) {\n\n\t\t\toutputNode = fract( timeNode );\n\n\t\t}\n\n\t\treturn outputNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\nexport default OscNode;\n", "import Node from '../core/Node.js';\nimport ConstNode from '../core/ConstNode.js';\nimport UVNode from '../accessors/UVNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport JoinNode from '../utils/JoinNode.js';\n\nclass SpriteSheetUVNode extends Node {\n\n\tconstructor( countNode, uvNode = new UVNode(), frameNode = new ConstNode( 0 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.countNode = countNode;\n\t\tthis.uvNode = uvNode;\n\t\tthis.frameNode = frameNode;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst count = this.countNode;\n\t\tconst uv = this.uvNode;\n\t\tconst frame = this.frameNode;\n\n\t\tconst one = new ConstNode( 1 );\n\n\t\tconst width = new SplitNode( count, 'x' );\n\t\tconst height = new SplitNode( count, 'y' );\n\n\t\tconst total = new OperatorNode( '*', width, height );\n\n\t\tconst roundFrame = new MathNode( MathNode.FLOOR, new MathNode( MathNode.MOD, frame, total ) );\n\n\t\tconst frameNum = new OperatorNode( '+', roundFrame, one );\n\n\t\tconst cell = new MathNode( MathNode.MOD, roundFrame, width );\n\t\tconst row = new MathNode( MathNode.CEIL, new OperatorNode( '/', frameNum, width ) );\n\t\tconst rowInv = new OperatorNode( '-', height, row );\n\n\t\tconst scale = new OperatorNode( '/', one, count );\n\n\t\tconst uvFrameOffset = new JoinNode( [\n\t\t\tnew OperatorNode( '*', cell, new SplitNode( scale, 'x' ) ),\n\t\t\tnew OperatorNode( '*', rowInv, new SplitNode( scale, 'y' ) )\n\t\t] );\n\n\t\tconst uvScale = new OperatorNode( '*', uv, scale );\n\t\tconst uvFrame = new OperatorNode( '+', uvScale, uvFrameOffset );\n\n\t\treturn uvFrame.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n}\n\nexport default SpriteSheetUVNode;\n", "import Node from '../core/Node.js';\nimport { ShaderNode, uv, add, mul, floor, mod, sign } from '../shadernode/ShaderNodeBaseElements.js';\n\nconst checkerShaderNode = new ShaderNode( ( inputs ) => {\n\n\tconst uv = mul( inputs.uv, 2.0 );\n\n\tconst cx = floor( uv.x );\n\tconst cy = floor( uv.y );\n\tconst result = mod( add( cx, cy ), 2.0 );\n\n\treturn sign( result );\n\n} );\n\nclass CheckerNode extends Node {\n\n\tconstructor( uvNode = uv() ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.uvNode = uvNode;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn checkerShaderNode.call( { uv: this.uvNode } ).build( builder );\n\n\t}\n\n}\n\nexport default CheckerNode;\n", "import Node from '../core/Node.js';\nimport MathNode from '../math/MathNode.js';\n\nclass FogNode extends Node {\n\n\tconstructor( colorNode, factorNode ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.factorNode = factorNode;\n\n\t}\n\n\tmix( outputNode ) {\n\n\t\treturn new MathNode( MathNode.MIX, outputNode, this.colorNode, this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn this.factorNode.build( builder, 'float' );\n\n\t}\n\n}\n\nFogNode.prototype.isFogNode = true;\n\nexport default FogNode;\n", "import FogNode from './FogNode.js';\nimport { smoothstep, negate, positionView } from '../shadernode/ShaderNodeBaseElements.js';\n\nclass FogRangeNode extends FogNode {\n\n\tconstructor( colorNode, nearNode, farNode ) {\n\n\t\tsuper( colorNode );\n\n\t\tthis.nearNode = nearNode;\n\t\tthis.farNode = farNode;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tthis.factorNode = smoothstep( this.nearNode, this.farNode, negate( positionView.z ) );\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nFogRangeNode.prototype.isFogRangeNode = true;\n\nexport default FogRangeNode;\n", "import { ShaderNode, add, sub, mul, exp2 } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst F_Schlick = new ShaderNode( ( inputs ) => {\n\n\tconst { f0, f90, dotVH } = inputs;\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tconst fresnel = exp2( mul( sub( mul( - 5.55473, dotVH ), 6.98316 ), dotVH ) );\n\n\treturn add( mul( f0, sub( 1.0, fresnel ) ), mul( f90, fresnel ) );\n\n} ); // validated\n\nexport default F_Schlick;\n", "import { ShaderNode, add, sub, mul, div, pow2, max, sqrt, EPSILON } from '../../shadernode/ShaderNodeBaseElements.js';\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = new ShaderNode( ( inputs ) => {\n\n\tconst { alpha, dotNL, dotNV } = inputs;\n\n\tconst a2 = pow2( alpha );\n\n\tconst gv = mul( dotNL, sqrt( add( a2, mul( sub( 1.0, a2 ), pow2( dotNV ) ) ) ) );\n\tconst gl = mul( dotNV, sqrt( add( a2, mul( sub( 1.0, a2 ), pow2( dotNL ) ) ) ) );\n\n\treturn div( 0.5, max( add( gv, gl ), EPSILON ) );\n\n} ); // validated\n\nexport default V_GGX_SmithCorrelated;\n", "import { ShaderNode, add, sub, mul, div, pow2 } from '../../shadernode/ShaderNodeBaseElements.js';\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nconst D_GGX = new ShaderNode( ( inputs ) => {\n\n\tconst { alpha, dotNH } = inputs;\n\n\tconst a2 = pow2( alpha );\n\n\tconst denom = add( mul( pow2( dotNH ), sub( a2, 1.0 ) ), 1.0 ); // avoid alpha = 0 with dotNH = 1\n\n\treturn mul( 1 / Math.PI, div( a2, pow2( denom ) ) );\n\n} ); // validated\n\nexport default D_GGX;\n", "import F_Schlick from './F_Schlick.js';\nimport V_GGX_SmithCorrelated from './V_GGX_SmithCorrelated.js';\nimport D_GGX from './D_GGX.js';\nimport {\n\tShaderNode, dotNV, add, mul, saturate, dot, pow2, normalize,\n\ttransformedNormalView, positionViewDirection\n} from '../../shadernode/ShaderNodeBaseElements.js';\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = new ShaderNode( ( inputs ) => {\n\n\tconst { lightDirection, f0, f90, roughness } = inputs;\n\n\tconst alpha = pow2( roughness ); // UE4's roughness\n\n\tconst halfDir = normalize( add( lightDirection, positionViewDirection ) );\n\n\tconst dotNL = saturate( dot( transformedNormalView, lightDirection ) );\n\t//const dotNV = saturate( dot( transformedNormalView, positionViewDirection ) );\n\tconst dotNH = saturate( dot( transformedNormalView, halfDir ) );\n\tconst dotVH = saturate( dot( positionViewDirection, halfDir ) );\n\n\tconst F = F_Schlick.call( { f0, f90, dotVH } );\n\n\tconst V = V_GGX_SmithCorrelated.call( { alpha, dotNL, dotNV } );\n\n\tconst D = D_GGX.call( { alpha, dotNH } );\n\n\treturn mul( F, mul( V, D ) );\n\n} ); // validated\n\nexport default BRDF_GGX;\n", "import { ShaderNode, mul } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst BRDF_Lambert = new ShaderNode( ( inputs ) => {\n\n\treturn mul( 1 / Math.PI, inputs.diffuseColor ); // punctual light\n\n} ); // validated\n\nexport default BRDF_Lambert;\n", "import { ShaderNode, max, abs, dFdx, dFdy, normalGeometry } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst getGeometryRoughness = new ShaderNode( () => {\n\n\tconst dxy = max( abs( dFdx( normalGeometry ) ), abs( dFdy( normalGeometry ) ) );\n\tconst geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\n\treturn geometryRoughness;\n\n} );\n\nexport default getGeometryRoughness;\n", "import getGeometryRoughness from './getGeometryRoughness.js';\nimport { ShaderNode, add, max, min } from '../../shadernode/ShaderNodeBaseElements.js';\n\nconst getRoughness = new ShaderNode( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst geometryRoughness = getGeometryRoughness.call();\n\n\tlet roughnessFactor = max( roughness, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\n\troughnessFactor = add( roughnessFactor, geometryRoughness );\n\troughnessFactor = min( roughnessFactor, 1.0 );\n\n\treturn roughnessFactor;\n\n} );\n\nexport default getRoughness;\n", "import BRDF_Lambert from './BSDF/BRDF_Lambert.js';\nimport BRDF_GGX from './BSDF/BRDF_GGX.js';\nimport {\n\tShaderNode, mul, saturate, dot, transformedNormalView,\n\tdiffuseColor, specularColor, roughness\n} from '../shadernode/ShaderNodeBaseElements.js';\n\nconst RE_Direct_Physical = new ShaderNode( ( inputs ) => {\n\n\tconst { lightDirection, lightColor, reflectedLight } = inputs;\n\n\tconst dotNL = saturate( dot( transformedNormalView, lightDirection ) );\n\tconst irradiance = mul( dotNL, lightColor );\n\n\treflectedLight.directSpecular.add( mul( irradiance, BRDF_GGX.call( { lightDirection, f0: specularColor, f90: 1, roughness } ) ) );\n\n\treflectedLight.directDiffuse.add( mul( irradiance, BRDF_Lambert.call( { diffuseColor: diffuseColor.rgb } ) ) );\n\n} );\n\nconst PhysicalLightingModel = new ShaderNode( ( inputs/*, builder*/ ) => {\n\n\tRE_Direct_Physical.call( inputs );\n\n} );\n\nexport default PhysicalLightingModel;\n", "// accessors\nimport CubeTextureNode from '../accessors/CubeTextureNode.js';\nimport InstanceNode from '../accessors/InstanceNode.js';\nimport ReflectNode from '../accessors/ReflectNode.js';\nimport SkinningNode from '../accessors/SkinningNode.js';\n\n// display\nimport ColorSpaceNode from '../display/ColorSpaceNode.js';\nimport NormalMapNode from '../display/NormalMapNode.js';\nimport ToneMappingNode from '../display/ToneMappingNode.js';\n\n// lights\nimport LightNode from '../lights/LightNode.js';\nimport LightsNode from '../lights/LightsNode.js';\nimport LightContextNode from '../lights/LightContextNode.js';\n\n// utils\nimport MatcapUVNode from '../utils/MatcapUVNode.js';\nimport MaxMipLevelNode from '../utils/MaxMipLevelNode.js';\nimport OscNode from '../utils/OscNode.js';\nimport SpriteSheetUVNode from '../utils/SpriteSheetUVNode.js';\nimport TimerNode from '../utils/TimerNode.js';\n\n// procedural\nimport CheckerNode from '../procedural/CheckerNode.js';\n\n// fog\nimport FogNode from '../fog/FogNode.js';\nimport FogRangeNode from '../fog/FogRangeNode.js';\n\n// shader node utils\nimport { nodeObject, nodeProxy, nodeImmutable } from './ShaderNode.js';\n\n//\n// Node Material Shader Syntax\n//\n\n// shader node utils\n\nexport * from './ShaderNodeBaseElements.js';\n\n// functions\n\nexport { default as BRDF_GGX } from '../functions/BSDF/BRDF_GGX.js'; // see https://github.com/tc39/proposal-export-default-from\nexport { default as BRDF_Lambert } from '../functions/BSDF/BRDF_Lambert.js';\nexport { default as D_GGX } from '../functions/BSDF/D_GGX.js';\nexport { default as F_Schlick } from '../functions/BSDF/F_Schlick.js';\nexport { default as V_GGX_SmithCorrelated } from '../functions/BSDF/V_GGX_SmithCorrelated.js';\n\nexport { default as getDistanceAttenuation } from '../functions/light/getDistanceAttenuation.js';\n\nexport { default as getGeometryRoughness } from '../functions/material/getGeometryRoughness.js';\nexport { default as getRoughness } from '../functions/material/getRoughness.js';\n\nexport { default as PhysicalLightingModel } from '../functions/PhysicalLightingModel.js';\n\n// accessors\n\nexport const cubeTexture = nodeProxy( CubeTextureNode );\n\nexport const instance = nodeProxy( InstanceNode );\n\nexport const reflectVector = nodeImmutable( ReflectNode, ReflectNode.VECTOR );\nexport const reflectCube = nodeImmutable( ReflectNode, ReflectNode.CUBE );\n\nexport const skinning = nodeProxy( SkinningNode );\n\n// display\n\nexport const colorSpace = ( node, encoding ) => nodeObject( new ColorSpaceNode( null, nodeObject( node ) ).fromEncoding( encoding ) );\nexport const normalMap = nodeProxy( NormalMapNode );\nexport const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\n\n// lights\n\nexport const light = nodeProxy( LightNode );\nexport const fromLights = ( lights ) => nodeObject( new LightsNode().fromLights( lights ) );\nexport const lightContext = nodeProxy( LightContextNode );\n\n// utils\n\nexport const matcapUV = nodeImmutable( MatcapUVNode );\nexport const maxMipLevel = nodeProxy( MaxMipLevelNode );\n\nexport const oscSine = nodeProxy( OscNode, OscNode.SINE );\nexport const oscSquare = nodeProxy( OscNode, OscNode.SQUARE );\nexport const oscTriangle = nodeProxy( OscNode, OscNode.TRIANGLE );\nexport const oscSawtooth = nodeProxy( OscNode, OscNode.SAWTOOTH );\n\nexport const spritesheetUV = nodeProxy( SpriteSheetUVNode );\n\nexport const timerLocal = nodeImmutable( TimerNode, TimerNode.LOCAL );\nexport const timerGlobal = nodeImmutable( TimerNode, TimerNode.GLOBAL );\nexport const timerDelta = nodeImmutable( TimerNode, TimerNode.DELTA );\n\n// procedural\n\nexport const checker = nodeProxy( CheckerNode );\n\n// fog\n\nexport const fog = nodeProxy( FogNode );\nexport const rangeFog = nodeProxy( FogRangeNode );\n"],
  "mappings": "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",
  "names": ["property", "data", "attribute", "texture", "code", "context", "code", "property", "property", "property", "position", "context", "nodeObject", "bool", "uint", "int", "float", "code", "call", "texture", "texture", "uv", "normalMap", "color", "toneMapping", "light", "positionView", "reflectedLight", "light", "uv", "texture", "uv", "uv", "dotNV", "roughness", "roughness", "reflectedLight", "color"]
}
